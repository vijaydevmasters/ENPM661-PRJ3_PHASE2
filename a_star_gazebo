import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist
import time
from nav_msgs.msg import Odometry
import math
class VelocityPublisher(Node):
    def __init__(self):
        super().__init__('velocity_publisher')
        self.publisher_ = self.create_publisher(Twist, '/cmd_vel', 10)
        self.subscription = self.create_subscription(
            Odometry,
            '/odom',  # Adjust the topic name as needed
            self.odom_callback,
            10  # QoS profile depth
        )
        
        self.linear_vel =  [((0.35, 0.0, 0.0), (0.35, -0.0)), ((0.59, 0.07, 0.6), (0.26, -0.6)), ((0.64, 0.14, 1.2), (0.09, -0.6)), ((0.77, 0.46, 1.2), (0.35, -0.0)), ((0.9, 0.56, 0.0), (0.17, 1.2)), ((1.25, 0.56, 0.0), (0.35, -0.0)), ((1.49, 0.48, -0.6), (0.26, 0.6)), ((1.65, 0.28, -1.2), (0.26, 0.6)), ((1.67, 0.03, -1.81), (0.26, 0.6)), ((1.68, -0.23, -1.2), (0.26, -0.6)), ((1.81, -0.55, -1.2), (0.35, -0.0)), ((1.94, -0.64, 0.0), (0.17, -1.2)), ((2.28, -0.64, 0.0), (0.35, -0.0)), ((2.63, -0.64, 0.0), (0.35, -0.0)), ((2.76, -0.55, 1.2), (0.17, -1.2)), ((2.78, -0.3, 1.81), (0.26, -0.6)), ((2.8, -0.04, 1.2), (0.26, 0.6)), ((2.92, 0.28, 1.2), (0.35, -0.0)), ((3.08, 0.48, 0.6), (0.26, 0.6)), ((3.36, 0.68, 0.6), (0.35, -0.0)), ((3.45, 0.7, 0.0), (0.09, 0.6)), ((3.79, 0.7, 0.0), (0.35, -0.0)), ((4.14, 0.7, 0.0), (0.35, -0.0)), ((4.38, 0.63, -0.6), (0.26, 0.6)), ((4.67, 0.43, -0.6), (0.35, -0.0)), ((4.95, 0.24, -0.6), (0.35, -0.0)), ((5.11, 0.04, -1.2), (0.26, 0.6)), ((5.13, -0.22, -1.81), (0.26, 0.6)), ((5.14, -0.47, -1.2), (0.26, -0.6))]
        self.index = 0  # To keep track of the current position in the velocity lists

        self.x = 0.0
        self.y = 0.0
        self.theta = 0.0
        self.flag=0
        self.start=0
        self.a=0
        self.b=0
        self.Distance=0




    def euler_from_quaternion(self,quaternion):
        """
        Convert quaternion (w in last place) to euler roll, pitch, yaw.
        quaternion = [x, y, z, w]
        """
        x, y, z, w = quaternion
        sinr_cosp = 2.0 * (w * x + y * z)
        cosr_cosp = 1.0 - 2.0 * (x * x + y * y)
        roll = math.atan2(sinr_cosp, cosr_cosp)

        sinp = 2.0 * (w * y - z * x)
        if math.fabs(sinp) >= 1:
            pitch = math.copysign(math.pi / 2, sinp)  # Use 90 degrees if out of range
        else:
            pitch = math.asin(sinp)

        siny_cosp = 2.0 * (w * z + x * y)
        cosy_cosp = 1.0 - 2.0 * (y * y + z * z)
        yaw = math.atan2(siny_cosp, cosy_cosp)

        return roll, pitch, yaw
    
    def odom_callback(self, msg):
        x = msg.pose.pose.position.x
        y = msg.pose.pose.position.y
        z = msg.pose.pose.position.z

        # Extracting quaternion orientation and converting it to Euler angles
        orientation_q = msg.pose.pose.orientation
        orientation_list = [orientation_q.x, orientation_q.y, orientation_q.z, orientation_q.w]
        roll, pitch, yaw = self.euler_from_quaternion(orientation_list)

        # Converting yaw from radians to degrees
        theta = yaw

        # Printing the extracted values
        
        self.x = round(x, 2)
        self.y = round(y, 2)
        self.theta =round(theta, 2)
        print(f'x: {self.x}, y: {self.y}, theta: {self.theta}')
        self.publish_velocity()



    def publish_velocity(self):
        if self.index < len(self.linear_vel):
            linear_velocity = self.linear_vel[self.index][1][0]
            angular_velocity = self.linear_vel[self.index][1][1]

            if (angular_velocity==0.0):
                    print("flag",self.flag) 

                    if self.flag==0:
                        if self.start==0:
                            print("x value",self.linear_vel[self.index][0][0])
                            print("y value",self.linear_vel[self.index][0][1])
                            self.Distance=math.sqrt((self.linear_vel[self.index][0][0])**2+(self.linear_vel[self.index][0][1])**2)
                            print(self.Distance)
                            self.flag=1
                            self.start=1
                        else:
                            self.Distance=math.sqrt((self.linear_vel[self.index][0][0]-self.linear_vel[self.index-1][0][0])**2+(self.linear_vel[self.index][0][1]-self.linear_vel[self.index-1][0][1])**2)
                            print(self.Distance)
                            self.a=self.x
                            self.b=self.y
                            self.flag=1

                    print("real time distance",math.sqrt((self.x-self.a)**2+(self.y-self.b)**2))
                    print("desired distance",self.Distance)
                    if math.sqrt((self.x-self.a)**2+(self.y-self.b)**2)<self.Distance*0.6:
                        print("sdfdf")
                        linear_velocity = linear_velocity
                    if math.sqrt((self.x-self.a)**2+(self.y-self.b)**2)>self.Distance*0.6:
                        print("sdkfhskdfhksdjfh")
                        linear_velocity = linear_velocity/10
                    if math.sqrt((self.x-self.a)**2+(self.y-self.b)**2)>=self.Distance:
                        self.flag=0
                        self.stop()
                        self.get_logger().info('Reached the desired position.')
                        self.index += 1  # Move to the next set of velocities
                        print("changed flag",self.flag)
                        


            else:
                
                linear_velocity = linear_velocity/5
                angular_velocity = angular_velocity/5
                if self.theta == -self.linear_vel[self.index][0][2]:
                    self.stop()
                    self.get_logger().info('Reached the desired position.')
                    self.index += 1  # Move to the next set of velocities

            
            vel_msg = Twist()
            vel_msg.linear.x = linear_velocity
            vel_msg.angular.z = angular_velocity
            self.publisher_.publish(vel_msg)
            self.get_logger().info(f'Publishing: Linear Vel = {linear_velocity}, Angular Vel = {angular_velocity}, index = {self.index}, len = {len(self.linear_vel)}')
            

        else:
            self.get_logger().info('Completed publishing all velocities.')
            vel_msg_stop = Twist()
            vel_msg_stop.linear.x = 0.0
            vel_msg_stop.angular.z = 0.0
            self.publisher_.publish(vel_msg_stop)
    def stop(self):
        svel_msg_stop = Twist()
        svel_msg_stop.linear.x = 0.0
        svel_msg_stop.angular.z = 0.0
        self.publisher_.publish(svel_msg_stop)
        

def main(args=None):
    rclpy.init(args=args)
    velocity_publisher = VelocityPublisher()
    rclpy.spin(velocity_publisher)
    velocity_publisher.destroy_node()
    rclpy.shutdown()

if __name__ == '__main__':
    main()
